<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="robots" content="index, follow">
        <meta name="author" content="Balaji Kasiraj">
        <meta name="description" content="How fast can you read 100 Billion records of data?">
        <meta name="keywords" content="SQL, Optimisation of SQL Queries, Millions of data records, Hive, Table Partitioning, HDFS">
        <meta property="og:url" content="https://sqlonline.in/OptimisedQueryWriting.html">
        <link rel="canonical" href="https://sqlonline.in/OptimisedQueryWriting.html">
        <title>Querying Billion records of Data</title>
        <link rel="stylesheet" href="assets/css/blog_article.css">
        <!-- Google Tag Manager -->
		<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
            })(window,document,'script','dataLayer','GTM-5L7GNQXZ');</script>
            <!-- End Google Tag Manager -->
    </head>
<body>
    <div class="navbar">
        <div class="nav-container">
            <a href="#" class="nav-logo">SQL Online</a>
            <a href="#" class="nav-home">Home</a>
        </div>
    </div>
    <div class="breadcrumbs">
        <a href="#">Home</a> > <a href="#">Articles</a> > <span>Query Optimization</span>
    </div>
    <div class="container">
        <header>
            <h1>How fast can you read 100 Billion records of data?</h1>
            <div class="last-updated">Last updated: 23 July 2024</div>
        </header>
        <article>
            <p>Maybe a few hundred years?</p>
            <p>Bring in a computer and it should still take a few hours to traverse through all these records.</p>
            <p>Companies like Amazon, Meta, PhonePe, Google etc churn out a few billion records of data every day. That is because of the extensive user base who use these products.</p>
            <p>With such large data comes the requirement of large computing power to retrieve them and that always comes with a dollar cost $$ for the company.</p>
            <p>The only alternative being, reduce the computation required. And this is where optimisation comes into picture.</p>
            <h2>Optimisation Methods</h2>
            <h3>1. Partitioning a Table</h3>
            <p><strong>What is partitioning?</strong></p>
            <p>By definition, partitioning is to segregate items into folders. <br> Ex: If you are a teacher, you would segregate each Studentâ€™s records into separate folders so that it can be fetched easily. The process is similar here.</p>
            <p>Let's understand it through an example.</p>
            <p><strong>Problem Statement: </strong>Given the Order list, fetch all the orders that were executed in January of 2024</p>
            <p>Given below are two data tables of the same data</p>
            <p><strong>Case 1 : Non Partitioned Dataset</strong></p>
            </p>
            <img src="images/QueryOptimization/Pic1.webp" alt="Non Partitioned Data" class="article-image">
            <p>
            <p>If you had to fetch the Orders from Jan 2024, you would have to traverse through all the 15 records and your output is 3 records. This will be 15 units of effort, i.e reading each line is one unit of effort.</p>
            <p><strong>Case 2 : Partitioned Data</strong></p>
            </p>
            <img src="images/QueryOptimization/Pic 2.webp" alt="Partitioned Data" class="article-image">
            <p>
            <p>If you see each Record is put into folders i.e year and month. <br> Considering that everything is in ascending order, your eyes will scroll down to 2024, then January and finally the records against it. There is absolutely no necessity for you to look at other years like 2023 or other months like February and March. This is essentially 3 units of effort against case 1 where it is 15 units.</p>
            <p>The entire computation is down by 80%. This is how optimisation works. Using a partition where clause to only fetch the records needed in the output, reduces the computation power and also the time taken for the query to run.</p>
            <p>Now when you scale this to say 1 TB of available data, you only end up processing 200GB of data or lesser (basis use case) and save on computation and time.</p>
        </article>
    </div>
</body>
</html>
